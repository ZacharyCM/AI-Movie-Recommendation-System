---
phase: 05-embeddings-rag-ai-explanations
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/package.json
  - backend/services/semantic_search.py
  - backend/routers/search.py
  - backend/main.py
  - frontend/src/lib/api.ts
  - frontend/src/hooks/useSemanticSearch.ts
  - frontend/src/components/search/CommandPalette.tsx
  - frontend/src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "User can press Cmd+K (or Ctrl+K) anywhere in the app to open a search overlay"
    - "User can type natural language queries like 'dark thriller like Zodiac' and see relevant results"
    - "Search results display movie title, year, and genres"
    - "Clicking a search result navigates to that movie's detail page"
    - "All search results are real movies from the catalog (no hallucinated titles)"
  artifacts:
    - path: "backend/services/semantic_search.py"
      provides: "SemanticSearchService with vector search"
      exports: ["SemanticSearchService"]
    - path: "backend/routers/search.py"
      provides: "GET /api/search/semantic endpoint"
      contains: "semantic"
    - path: "frontend/src/components/search/CommandPalette.tsx"
      provides: "Cmd+K search overlay component"
      exports: ["CommandPalette"]
    - path: "frontend/src/hooks/useSemanticSearch.ts"
      provides: "React hook for semantic search"
      exports: ["useSemanticSearch"]
  key_links:
    - from: "frontend/src/components/search/CommandPalette.tsx"
      to: "/api/search/semantic"
      via: "useSemanticSearch hook with debounced fetch"
      pattern: "useSemanticSearch"
    - from: "backend/routers/search.py"
      to: "backend/services/semantic_search.py"
      via: "SemanticSearchService.search() call"
      pattern: "search_service"
    - from: "backend/services/semantic_search.py"
      to: "backend/ml/embeddings/store.py"
      via: "EmbeddingStore.query_similar() for vector retrieval"
      pattern: "embedding_store"
    - from: "frontend/src/app/layout.tsx"
      to: "frontend/src/components/search/CommandPalette.tsx"
      via: "CommandPalette rendered globally in root layout"
      pattern: "CommandPalette"
---

<objective>
Implement natural language movie search using ChromaDB vector search with a Cmd+K command palette interface.

Purpose: Users can discover movies using natural language queries ("something gritty like The Batman but with 80s vibes") instead of exact title search. This uses the ChromaDB embeddings from Plan 05-01 for semantic matching.

Output: Global Cmd+K search overlay that performs semantic vector search and displays relevant movie results from the catalog.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-embeddings-rag-ai-explanations/05-RESEARCH.md
@.planning/phases/05-embeddings-rag-ai-explanations/05-01-SUMMARY.md

@backend/main.py
@backend/dependencies.py
@backend/routers/movies.py
@frontend/src/lib/api.ts
@frontend/src/app/layout.tsx
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SemanticSearchService and API endpoint</name>
  <files>
    backend/services/semantic_search.py
    backend/routers/search.py
    backend/main.py
  </files>
  <action>
    1. Create `backend/services/semantic_search.py` with `SemanticSearchService` class:

       **Constructor:** Takes `EmbeddingStore` instance (from dependencies). Loads `SentenceTransformer('all-MiniLM-L6-v2')` model for encoding queries.

       **search(query: str, top_n: int = 10) -> list[dict]:** Main search method:
       a. Encode the user's query text into an embedding vector using the sentence-transformer model.
       b. Query ChromaDB via `embedding_store.query_similar(query_embedding, n_results=top_n)`.
       c. For each result, return: `{ movie_id, title, year, genres, distance }` from ChromaDB metadata.
       d. Results are already ranked by cosine similarity (closest first).

       **Important notes:**
       - Do NOT use Claude for re-ranking in MVP. Vector search alone is sufficient for the current catalog size (~250 movies). Re-ranking adds latency and cost. This can be added later if needed.
       - The SentenceTransformer model should be loaded once in the constructor, not per-request.
       - The model is the SAME model used to generate embeddings (all-MiniLM-L6-v2). Using a different model would produce incompatible vectors.

    2. Create `backend/routers/search.py`:
       - `router = APIRouter(prefix="/api/search", tags=["search"])`.
       - `GET /api/search/semantic?q={query}&top_n={10}`:
         - `q` is required, minimum 2 characters.
         - `top_n` is optional, default 10, max 30.
         - No auth required (search is public, like the existing movie browse).
         - Returns `{ results: [{ movie_id, title, year, genres, score }], query }`.
         - Score is `1 - distance` (convert ChromaDB distance to similarity score 0-1).
       - Add Pydantic response model: `SemanticSearchResult` and `SemanticSearchResponse`.

    3. Update `backend/main.py`:
       - Import and include the new search router: `from routers.search import router as search_router`.
       - `app.include_router(search_router)`.
       - In the lifespan function, initialize SentenceTransformer model (shared across requests). Store on `embedding_store` or create `semantic_search_service` in `dependencies.py` as a shared instance.

    Keep the search endpoint simple and fast. No auth required. Vector search should respond in <200ms for 250 movies.
  </action>
  <verify>
    Run: `cd backend && python -c "from services.semantic_search import SemanticSearchService; print('SemanticSearchService imported')"` -- should succeed.

    Start server, then test: `curl "http://localhost:8000/api/search/semantic?q=dark+thriller"` -- should return movie results sorted by semantic relevance.

    Test: `curl "http://localhost:8000/api/search/semantic?q=romantic+comedy+set+in+new+york"` -- results should contain relevant romance/comedy movies.
  </verify>
  <done>
    SemanticSearchService performs vector search using same sentence-transformer model. API endpoint at /api/search/semantic accepts natural language queries. Results include movie_id, title, year, genres, and similarity score. Response time <200ms for catalog of ~250 movies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Cmd+K CommandPalette with cmdk and integrate globally</name>
  <files>
    frontend/package.json
    frontend/src/lib/api.ts
    frontend/src/hooks/useSemanticSearch.ts
    frontend/src/components/search/CommandPalette.tsx
    frontend/src/app/layout.tsx
  </files>
  <action>
    1. Install cmdk: `cd frontend && pnpm install cmdk`.

    2. Add `fetchSemanticSearch` function to `frontend/src/lib/api.ts`:
       ```typescript
       export interface SemanticSearchResult {
         movie_id: number;
         title: string;
         year: string;
         genres: string;
         score: number;
       }

       export interface SemanticSearchResponse {
         results: SemanticSearchResult[];
         query: string;
       }

       export async function fetchSemanticSearch(
         query: string,
         topN: number = 10
       ): Promise<SemanticSearchResponse> {
         const res = await fetch(
           `${API_URL}/api/search/semantic?q=${encodeURIComponent(query)}&top_n=${topN}`,
           { cache: "no-store" }
         );
         if (!res.ok) throw new Error(res.statusText);
         return res.json();
       }
       ```

    3. Create `frontend/src/hooks/useSemanticSearch.ts`:
       - Exports a `useSemanticSearch()` hook.
       - State: `query` (string), `results` (SemanticSearchResult[]), `isLoading` (boolean).
       - Uses `useState` + `useEffect` with 300ms debounce (same pattern as existing search in browse page).
       - Only triggers fetch when `query.length >= 3`.
       - Returns `{ query, setQuery, results, isLoading }`.
       - Do NOT use TanStack Query here -- the search is ephemeral and doesn't need caching. Simple state + fetch is appropriate for command palette.

    4. Create `frontend/src/components/search/CommandPalette.tsx`:
       - Uses `Command` from `cmdk` library.
       - Global keyboard listener: `Cmd+K` (Mac) / `Ctrl+K` (Windows) toggles the dialog open/closed.
       - `Command.Dialog` with `open` / `onOpenChange` state.
       - `Command.Input` bound to `query` from `useSemanticSearch` hook. Override cmdk's built-in filtering by setting `shouldFilter={false}` on the `Command` root (we filter server-side via embeddings, not client-side).
       - `Command.List` renders results:
         - Each `Command.Item` shows: movie title, year, genres (e.g., "The Dark Knight (2008) - Action, Crime, Drama").
         - `onSelect` navigates to `/movies/{movie_id}` using `window.location.href` (or Next.js router).
         - Close the dialog on selection.
       - `Command.Empty` shows "Searching..." when loading, "No results found." when empty + not loading.
       - Styling: Full dark theme to match project aesthetic.
         - Dialog backdrop: `bg-black/50 backdrop-blur-sm` fixed overlay.
         - Dialog container: `bg-slate-900 border border-slate-700 rounded-xl shadow-2xl max-w-lg mx-auto mt-[20vh]`.
         - Input: `bg-transparent text-white placeholder-slate-500 border-b border-slate-700 p-4`.
         - Items: `text-slate-200 hover:bg-slate-800 px-4 py-3 cursor-pointer`.
         - Active item: `bg-slate-800` (cmdk handles aria-selected).
       - Add a hint in the navbar or bottom of page: "Press Cmd+K to search" (subtle, muted text).
       - Include a search icon (from lucide-react) in the input area.

    5. Update `frontend/src/app/layout.tsx`:
       - Import `CommandPalette`.
       - Add `<CommandPalette />` inside the `<body>` element, after the `Providers` wrapper.
       - The CommandPalette renders as a fixed overlay, so position in the tree doesn't matter much, but it should be available on all pages.
       - Since layout.tsx is a Server Component, wrap CommandPalette import with a client boundary -- either make CommandPalette a 'use client' component (it already is) and import it, or use a dynamic import. The simplest approach: just import and render it since Next.js handles client component boundaries automatically when the component has 'use client'.

    Design notes:
    - cmdk provides unstyled components. All styling is via Tailwind classes.
    - The `shouldFilter={false}` prop is CRITICAL -- without it, cmdk tries to client-side filter results using its built-in fuzzy match, which conflicts with our server-side semantic search.
    - Keep the overlay simple: input + results list. No categories, tabs, or recent searches in MVP.
  </action>
  <verify>
    Run: `cd frontend && pnpm build` -- should compile without TypeScript errors.

    Manual test: Open the app in browser, press Cmd+K, type "dark thriller" -- search overlay should appear and show relevant movie results from the catalog. Click a result to navigate to its detail page.
  </verify>
  <done>
    Cmd+K command palette opens globally. Natural language queries return semantically relevant movies via ChromaDB vector search. Results show title, year, and genres. Clicking a result navigates to the movie detail page. Dark theme styling matches the rest of the app. 300ms debounce prevents excessive API calls.
  </done>
</task>

</tasks>

<verification>
1. Press Cmd+K anywhere in the app -- search overlay opens.
2. Type "dark thriller" -- relevant results appear within 500ms.
3. Type "romantic comedy set in paris" -- results reflect semantic understanding, not just keyword match.
4. Click a result -- navigates to movie detail page and overlay closes.
5. Press Escape -- overlay closes.
6. API: `GET /api/search/semantic?q=sci-fi+adventure` returns valid JSON with movie results.
7. All results are real movies from the catalog (no hallucinated titles -- guaranteed by ChromaDB-only retrieval).
</verification>

<success_criteria>
- Cmd+K overlay opens and closes with keyboard shortcut.
- Natural language queries return semantically relevant movie results.
- All results are real catalog movies (vector search guarantees this).
- UI matches dark theme with smooth interactions.
- Search responds within 500ms including network round-trip.
</success_criteria>

<output>
After completion, create `.planning/phases/05-embeddings-rag-ai-explanations/05-03-SUMMARY.md`
</output>
