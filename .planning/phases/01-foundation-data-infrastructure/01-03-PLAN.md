---
phase: 01-foundation-data-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/routers/__init__.py
  - backend/routers/movies.py
  - backend/schemas/movie.py
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "GET /api/movies returns a paginated list of popular movies from TMDB"
    - "GET /api/movies/search?query=batman returns movies matching the search term"
    - "GET /api/movies/123 returns full movie details including cast, genres, and trailers"
    - "All endpoints return properly structured JSON matching Pydantic response schemas"
    - "Invalid movie IDs return 404, missing query params return 422"
  artifacts:
    - path: "backend/routers/movies.py"
      provides: "Movie API endpoints: popular, search, detail"
      exports: ["router"]
      min_lines: 40
    - path: "backend/schemas/movie.py"
      provides: "Pydantic response models for movie data"
      contains: "class MovieResponse"
  key_links:
    - from: "backend/routers/movies.py"
      to: "backend/services/tmdb.py"
      via: "TMDBService import and method calls"
      pattern: "TMDBService"
    - from: "backend/main.py"
      to: "backend/routers/movies.py"
      via: "app.include_router"
      pattern: "include_router.*movies"
---

<objective>
Build the FastAPI backend endpoints that proxy TMDB API data for the frontend catalog, exposing popular movies, search, and movie details through a clean REST API.

Purpose: The frontend cannot call TMDB directly (API key must stay server-side). These endpoints provide the data layer for the catalog browse page, search, and movie detail page built in Plan 04.

Output: Three working API endpoints at /api/movies, /api/movies/search, and /api/movies/{id} returning structured movie data from TMDB.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic response schemas for movie data</name>
  <files>
    backend/schemas/__init__.py
    backend/schemas/movie.py
  </files>
  <action>
    Create Pydantic models that define the API response shape. These validate and serialize TMDB data before sending to the frontend.

    `backend/schemas/__init__.py`: empty file

    `backend/schemas/movie.py`:
    - `class MovieResponse(BaseModel)`: id (int), title (str), overview (str), poster_path (str | None), backdrop_path (str | None), release_date (str), vote_average (float), vote_count (int), genre_ids (list[int])
    - `class GenreResponse(BaseModel)`: id (int), name (str)
    - `class CastMemberResponse(BaseModel)`: id (int), name (str), character (str), profile_path (str | None), order (int)
    - `class VideoResponse(BaseModel)`: id (str), key (str), name (str), site (str), type (str)
    - `class MovieDetailResponse(MovieResponse)`: runtime (int | None), genres (list[GenreResponse]), tagline (str | None), credits_cast (list[CastMemberResponse], alias for nested credits.cast), videos_results (list[VideoResponse], alias for nested videos.results)
    - `class PaginatedMovieResponse(BaseModel)`: page (int), results (list[MovieResponse]), total_pages (int), total_results (int)
    - All models use `model_config = ConfigDict(from_attributes=True)` for ORM mode compatibility
    - For MovieDetailResponse: use a `@model_validator(mode="before")` or `@classmethod` to flatten TMDB's nested `credits.cast` and `videos.results` into top-level fields. Alternatively, define the response to match TMDB structure directly with nested objects: `credits: CreditsResponse` containing `cast: list[CastMemberResponse]`, and `videos: VideosResponse` containing `results: list[VideoResponse]`.
    - Prefer matching TMDB structure directly (nested credits/videos) to avoid complex flattening -- this keeps frontend types aligned with API response.
  </action>
  <verify>
    - `cd backend && python -c "from schemas.movie import MovieResponse, MovieDetailResponse, PaginatedMovieResponse; print('OK')"`
    - All models instantiate without error with sample data
  </verify>
  <done>Pydantic response schemas define the contract between backend API and frontend. MovieResponse, MovieDetailResponse, and PaginatedMovieResponse cover all movie data shapes needed for catalog and detail views.</done>
</task>

<task type="auto">
  <name>Task 2: Create movie API router with popular, search, and detail endpoints</name>
  <files>
    backend/routers/__init__.py
    backend/routers/movies.py
    backend/main.py
  </files>
  <action>
    Build the FastAPI router with three endpoints that proxy TMDB data.

    `backend/routers/__init__.py`: empty file

    `backend/routers/movies.py`:
    - Import `APIRouter`, `HTTPException`, `Query` from fastapi
    - Import `TMDBService` from `services.tmdb`
    - Import response schemas from `schemas.movie`
    - Create `router = APIRouter(prefix="/api/movies", tags=["movies"])`
    - Instantiate `tmdb_service = TMDBService()`

    Endpoints:

    `GET /api/movies` (popular movies):
    - Query param: `page: int = Query(1, ge=1, le=500)` (TMDB max page)
    - Calls `tmdb_service.get_popular(page=page)`
    - Returns `PaginatedMovieResponse`
    - On TMDB error: catch httpx.HTTPStatusError, return 502 Bad Gateway with "Failed to fetch movies from TMDB"

    `GET /api/movies/search`:
    - Query params: `query: str = Query(..., min_length=1)`, `page: int = Query(1, ge=1, le=500)`
    - Calls `tmdb_service.search_movies(query=query, page=page)`
    - Returns `PaginatedMovieResponse`
    - Empty query handled by FastAPI validation (422)
    - On TMDB error: catch httpx.HTTPStatusError, return 502

    `GET /api/movies/{movie_id}`:
    - Path param: `movie_id: int`
    - Calls `tmdb_service.get_movie_details(movie_id=movie_id)`
    - Returns `MovieDetailResponse`
    - On TMDB 404: catch and re-raise as HTTPException(404, "Movie not found")
    - On other TMDB error: return 502

    Update `backend/main.py`:
    - Import `router` from `routers.movies`
    - Add `app.include_router(router)` after CORS setup
    - Keep existing `/health` endpoint

    NOTE: Order the endpoints carefully. Place `/api/movies/search` BEFORE `/api/movies/{movie_id}` in the router, or FastAPI will try to parse "search" as a movie_id integer and return 422. Use explicit path declarations or ensure the search endpoint is registered first.
  </action>
  <verify>
    - Start backend: `cd backend && source venv/bin/activate && uvicorn main:app --reload --port 8000`
    - If TMDB_API_KEY is set in .env:
      - `curl http://localhost:8000/api/movies` returns JSON with `page`, `results` array of movies, `total_pages`
      - `curl "http://localhost:8000/api/movies/search?query=batman"` returns movies containing "batman"
      - `curl http://localhost:8000/api/movies/550` returns Fight Club details with cast and videos
      - `curl http://localhost:8000/api/movies/99999999` returns 404
    - If TMDB_API_KEY is not set: endpoints return 502 (expected, confirms error handling)
    - `curl "http://localhost:8000/api/movies/search"` (missing query) returns 422 validation error
    - `curl http://localhost:8000/docs` shows Swagger UI with all three endpoints documented
  </verify>
  <done>Three API endpoints return TMDB data with proper validation, error handling, and Swagger documentation. Popular movies paginate, search filters by query, and detail endpoint returns full movie info with cast and trailers.</done>
</task>

</tasks>

<verification>
- All Python imports work: `from routers.movies import router; from schemas.movie import MovieResponse`
- FastAPI starts and includes movie router
- Swagger docs at /docs show all endpoints with request/response schemas
- Error handling returns appropriate HTTP status codes (404, 422, 502)
- Response shapes match frontend TypeScript types from Plan 01
</verification>

<success_criteria>
1. GET /api/movies returns paginated popular movies from TMDB
2. GET /api/movies/search?query=X returns matching movies
3. GET /api/movies/{id} returns movie details with cast and videos
4. Invalid inputs return proper error codes (404, 422)
5. TMDB failures return 502 with descriptive message
6. Swagger UI documents all endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-infrastructure/01-03-SUMMARY.md`
</output>
