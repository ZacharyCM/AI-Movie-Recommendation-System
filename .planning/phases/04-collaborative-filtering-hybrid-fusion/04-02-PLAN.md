---
phase: 04-collaborative-filtering-hybrid-fusion
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/services/recommender.py
  - backend/main.py
  - backend/routers/recommendations.py
  - backend/schemas/recommendation.py
  - frontend/src/components/recommendations/RecommendationSection.tsx
autonomous: true

must_haves:
  truths:
    - "User with 20+ ratings sees recommendations influenced by collaborative filtering (hybrid_collaborative_heavy strategy)"
    - "User with 5-19 ratings sees hybrid recommendations weighted toward content-based (hybrid_content_heavy strategy)"
    - "User with < 5 ratings sees popularity fallback (unchanged from Phase 3)"
    - "Recommendations include 10-20% exploration picks from outside the user's established taste profile"
    - "SVD model is loaded at FastAPI startup alongside existing TF-IDF models"
    - "Frontend displays correct section title and messaging for all strategy types"
  artifacts:
    - path: "backend/services/recommender.py"
      provides: "HybridRecommenderService with content-based + collaborative fusion + diversity injection"
      contains: "hybrid_recommendations"
    - path: "backend/main.py"
      provides: "Lifespan loads SVD model + trainset alongside TF-IDF models"
      contains: "svd_model"
    - path: "backend/routers/recommendations.py"
      provides: "Updated endpoint returning hybrid strategy metadata"
      contains: "hybrid"
    - path: "backend/schemas/recommendation.py"
      provides: "Updated schema with hybrid strategy types"
      contains: "hybrid_collaborative_heavy"
    - path: "frontend/src/components/recommendations/RecommendationSection.tsx"
      provides: "Updated UI handling hybrid strategy types"
      contains: "hybrid"
  key_links:
    - from: "backend/services/recommender.py"
      to: "backend/ml/models/svd_model.pkl"
      via: "joblib.load at startup via main.py lifespan"
      pattern: "svd_model"
    - from: "backend/services/recommender.py"
      to: "backend/services/recommender.py (content-based)"
      via: "get_content_based_scores calls existing get_recommendations logic"
      pattern: "content.*score"
    - from: "backend/routers/recommendations.py"
      to: "backend/services/recommender.py"
      via: "calls hybrid_recommendations method"
      pattern: "hybrid_recommendations"
    - from: "frontend/src/components/recommendations/RecommendationSection.tsx"
      to: "API response strategy field"
      via: "strategy-based rendering for hybrid types"
      pattern: "hybrid"
---

<objective>
Integrate collaborative filtering into the recommendation pipeline with adaptive weighted fusion, diversity injection, and updated API/UI strategy handling.

Purpose: This plan connects the SVD model (trained in Plan 01) to the existing content-based recommendation engine through a hybrid fusion layer. The fusion weights adapt based on user rating count (cold start = content-only, established = 70% CF + 30% content). Diversity injection adds 10-20% exploration picks to prevent filter bubbles. The API and frontend are updated to reflect the new hybrid strategies.

Output: Working hybrid recommendation pipeline end-to-end from SVD model loading through API response to frontend display.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-collaborative-filtering-hybrid-fusion/04-RESEARCH.md
@.planning/phases/04-collaborative-filtering-hybrid-fusion/04-01-SUMMARY.md
@.planning/phases/03-content-based-recommendations/03-01-SUMMARY.md
@.planning/phases/03-content-based-recommendations/03-02-SUMMARY.md

Key existing files to modify:
@backend/services/recommender.py (current content-based RecommenderService)
@backend/main.py (lifespan model loading)
@backend/routers/recommendations.py (recommendation endpoint)
@backend/schemas/recommendation.py (response schemas)
@frontend/src/components/recommendations/RecommendationSection.tsx (strategy display)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hybrid fusion in RecommenderService with adaptive weights and diversity injection</name>
  <files>
    backend/services/recommender.py
    backend/main.py
    backend/schemas/recommendation.py
  </files>
  <action>
    **Update `backend/services/recommender.py`** -- extend the existing RecommenderService with hybrid fusion capabilities. Do NOT break existing content-based methods; ADD new methods alongside them.

    **Add new instance variables in `__init__`:**
    - `self.svd_model = None`
    - `self.cf_trainset = None`

    **Add new method `load_collaborative_model(self, model_dir: str)`:**
    - Load `svd_model.pkl` and `cf_trainset.pkl` from model_dir using joblib
    - Handle missing files gracefully (log warning, leave as None -- same pattern as load_model)
    - Log success with model info

    **Add new method `is_collaborative_loaded(self) -> bool`:**
    - Returns True if svd_model and cf_trainset are both not None

    **Add new method `calculate_alpha(self, user_rating_count: int) -> float`:**
    - `< 5 ratings`: return 0.0 (pure content-based / popularity fallback)
    - `5-19 ratings`: return `0.3 * (user_rating_count - 5) / 15` (gradual transition, 0.0 to 0.3)
    - `20+ ratings`: return 0.7 (collaborative-heavy hybrid)

    **Add new method `get_cf_scores(self, user_id: str, candidate_movie_ids: list[int]) -> dict[int, float]`:**
    - For each movie_id in candidates, call `self.svd_model.predict(user_id, movie_id)`
    - If prediction.details['was_impossible'] is True, use 3.0 as neutral fallback
    - Otherwise use prediction.est
    - Normalize all scores to 0-1 range: `(score - min) / (max - min)` with safe handling for max == min (return 0.5 for all)
    - Return dict mapping movie_id -> normalized_score

    **Add new method `get_diversity_picks(self, user_ratings: list[dict], hybrid_scores: dict[int, float], rated_ids: set, num_picks: int) -> list[dict]`:**
    - Get all movie IDs from the catalog that aren't rated and aren't in top recommendations
    - Sort all hybrid_scores descending
    - Pick from 50th-80th percentile range (mid-ranked movies with decent scores)
    - Use `random.sample` to select num_picks from this pool
    - Return list of `{"movie_id": int, "score": float}` dicts
    - If pool too small, sample from whatever is available

    **Add new method `hybrid_recommendations(self, user_id: str, ratings: list[dict], top_n: int = 10, diversity_ratio: float = 0.15) -> tuple[list[dict], str]`:**
    - Calculate alpha from len(ratings)
    - If alpha == 0.0 OR collaborative model not loaded: fall through to content-based only
      - Call existing `self.get_recommendations(ratings, top_n)` and return with strategy "content_based"
    - Get content-based scores for all unrated movies:
      - Build user profile (existing method)
      - Compute cosine similarity against all movies (existing pattern from get_recommendations)
      - Store as dict: movie_id -> content_score (already 0-1 range from cosine similarity)
    - Get CF scores for the same unrated movies:
      - Call `self.get_cf_scores(user_id, list(content_scores.keys()))`
    - Compute hybrid scores: `(1 - alpha) * content_score + alpha * cf_score` for each movie
    - Sort by hybrid score descending
    - Calculate diversity: `num_explore = max(1, int(top_n * diversity_ratio))`
    - `num_exploit = top_n - num_explore`
    - Take top num_exploit as exploit picks
    - Get num_explore diversity picks from mid-ranked range
    - Combine exploit + explore picks
    - Determine strategy string:
      - alpha < 0.5: "hybrid_content_heavy"
      - alpha >= 0.5: "hybrid_collaborative_heavy"
    - Return (recommendations_list, strategy)

    **Update `backend/main.py` lifespan:**
    - After existing `recommender_service.load_model("ml/models")`, add:
    - `recommender_service.load_collaborative_model("ml/models")`
    - Log whether collaborative model was loaded successfully

    **Update `backend/schemas/recommendation.py`:**
    - Update the `reason` field docstring to include new hybrid types
    - Update `strategy` field docstring: now includes "content_based", "popularity_fallback", "hybrid_content_heavy", "hybrid_collaborative_heavy"
    - No structural changes needed (fields are already strings)

    **Important:**
    - Keep ALL existing methods working (get_recommendations, get_popular_fallback, build_user_profile)
    - The hybrid_recommendations method is a NEW entry point that WRAPS the existing content-based logic
    - Import `random` at top of file for diversity sampling
    - Import `joblib` (already imported)
    - The `user_id` parameter for CF predictions should be the real Supabase UUID string (or "ml_X" for MovieLens users) -- Surprise handles string user IDs
    - For real users not in the trainset, SVD.predict() returns the global mean with was_impossible=True. This is handled gracefully by falling back to neutral score.
  </action>
  <verify>
    Run: `cd /Users/zacharym/netflixrecs/backend && python -c "from services.recommender import RecommenderService; r = RecommenderService(); r.load_model('ml/models'); r.load_collaborative_model('ml/models'); print('Content loaded:', r.is_loaded()); print('CF loaded:', r.is_collaborative_loaded()); print('Alpha(3):', r.calculate_alpha(3)); print('Alpha(10):', r.calculate_alpha(10)); print('Alpha(25):', r.calculate_alpha(25))"`
    Expected: Content loaded: True, CF loaded: True, Alpha(3): 0.0, Alpha(10): ~0.1, Alpha(25): 0.7
    Also verify: `python -c "from main import app; print('App created successfully')"`
  </verify>
  <done>
    RecommenderService has hybrid_recommendations method combining content-based + collaborative scores with adaptive alpha weights and diversity injection. SVD model loads at startup. Alpha returns 0.0 for < 5 ratings, 0.0-0.3 for 5-19, 0.7 for 20+.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update recommendation endpoint and frontend for hybrid strategies</name>
  <files>
    backend/routers/recommendations.py
    frontend/src/components/recommendations/RecommendationSection.tsx
  </files>
  <action>
    **Update `backend/routers/recommendations.py`:**
    - The endpoint currently has two code paths: popularity_fallback (< 5 ratings) and content_based (5+ ratings)
    - Replace the content_based path (the `else` branch for 5+ ratings) with a call to `recommender_service.hybrid_recommendations(user_id, ratings, top_n)`
    - This returns `(recommendations_list, strategy)` where strategy is "content_based", "hybrid_content_heavy", or "hybrid_collaborative_heavy"
    - The popularity_fallback path (< 5 ratings) stays UNCHANGED
    - For the hybrid path:
      - Call `recommender_service.hybrid_recommendations(user_id=user_id, ratings=ratings, top_n=top_n)`
      - Get back (recommended_items, strategy)
      - Fetch TMDB details for each recommendation (same pattern as existing code)
      - Set each recommendation's `reason` to the strategy string
      - Return RecommendationListResponse with the strategy from hybrid_recommendations
    - If hybrid_recommendations returns an empty list (model issues), fall back to existing content-based logic

    **Update `frontend/src/components/recommendations/RecommendationSection.tsx`:**
    - The component currently handles two strategies: "popularity_fallback" and "content_based"
    - Add handling for "hybrid_content_heavy" and "hybrid_collaborative_heavy":
      - Both hybrid strategies use title "Recommended for You" (same as content_based)
      - For "hybrid_collaborative_heavy", add a small subtitle: "Powered by users with similar taste" (in text-xs text-slate-500)
      - For "hybrid_content_heavy", no subtitle needed (same as content_based)
    - Update the strategy-based title logic:
      - `popularity_fallback` -> "Popular Right Now" (unchanged)
      - `content_based` -> "Recommended for You" (unchanged)
      - `hybrid_content_heavy` -> "Recommended for You" (same)
      - `hybrid_collaborative_heavy` -> "Recommended for You" (same, with subtitle)
    - The empty state for content_based strategy rendering stays the same
    - Add empty state handling for hybrid strategies too (if recommendations.length === 0 and strategy starts with "hybrid")

    **Important:**
    - The API contract (RecommendationListResponse shape) does NOT change -- only the `strategy` string values expand
    - The frontend Recommendation type and fetchRecommendations function need NO changes (strategy is already a string)
    - Keep the popularity_fallback subtitle "Rate 5+ movies to get personalized recommendations" unchanged
    - The hybrid strategies are backward-compatible -- if a user has < 5 ratings, they still get popularity_fallback
  </action>
  <verify>
    Backend: `cd /Users/zacharym/netflixrecs/backend && python -c "from routers.recommendations import router; print('Router loaded:', router.prefix)"`
    Frontend: `cd /Users/zacharym/netflixrecs/frontend && npx tsc --noEmit --pretty 2>&1 | head -20` (should show no errors in RecommendationSection.tsx)
    Grep for hybrid: `grep -r 'hybrid' backend/routers/recommendations.py backend/services/recommender.py`
  </verify>
  <done>
    Recommendation endpoint calls hybrid_recommendations for users with 5+ ratings, returning "content_based", "hybrid_content_heavy", or "hybrid_collaborative_heavy" strategy. Frontend displays appropriate titles and subtitles for each strategy. Popularity fallback path unchanged for cold-start users.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from services.recommender import RecommenderService"` -- no import errors
2. `python -c "from main import app"` -- app starts with both TF-IDF and SVD models
3. Recommender.calculate_alpha(3) == 0.0, calculate_alpha(10) ~= 0.1, calculate_alpha(25) == 0.7
4. hybrid_recommendations returns correct strategy strings based on user rating count
5. Diversity injection adds exploration picks (at least 1 out of 10 recommendations)
6. Frontend TypeScript compiles without errors
7. Frontend handles all four strategy types: popularity_fallback, content_based, hybrid_content_heavy, hybrid_collaborative_heavy
8. API response shape (RecommendationListResponse) is backward-compatible
</verification>

<success_criteria>
- User with 20+ ratings gets "hybrid_collaborative_heavy" strategy with alpha=0.7 (70% CF, 30% content)
- User with 5-19 ratings gets "hybrid_content_heavy" strategy with alpha 0.0-0.3
- User with < 5 ratings gets "popularity_fallback" (unchanged)
- At least 1 of every 10 recommendations is a diversity/exploration pick
- SVD model loaded at startup alongside TF-IDF model
- Frontend displays correct titles for all strategy types
- No regressions in existing recommendation flow
</success_criteria>

<output>
After completion, create `.planning/phases/04-collaborative-filtering-hybrid-fusion/04-02-SUMMARY.md`
</output>
